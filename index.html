<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>chrono.io</title>
    <style>
        :root {
            --bg-color: #000;
            --primary-color: #fff;
            --secondary-color: #333;
            --secondary-hover: #555;
            --accent-color: #f00;

            --face-size: 400px;
            --face-border: 4px;
            --center-dot-size: 12px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-color);
            color: var(--primary-color);
            font-family: monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        .ui-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: row-reverse;
            gap: 10px;
        }

        .btn {
            background: var(--secondary-color);
            color: var(--primary-color);
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-family: monospace;
            transition: background 0.2s ease;
        }

        .btn:hover { background: var(--secondary-hover); }

        #hideBtn { position: fixed; bottom: 20px; left: 20px; padding: 8px 12px; font-size: 16px; }

        .ui-hidden .ui-controls { display: none; }

        .state-digital #mode, .state-digital #numbers { display: none; }
        .state-analog #format { display: none; }

        #digital { font-size: 80px; letter-spacing: 5px; }
        .state-digital #analog { display: none; }
        .state-analog #digital { display: none; }

        .clock-face {
            width: var(--face-size);
            height: var(--face-size);
            border: var(--face-border) solid var(--primary-color);
            border-radius: 50%;
            position: relative;
        }

        .marker {
            position: absolute;
            background: var(--primary-color);
            left: 50%;
            top: 0;
            transform-origin: center calc(var(--face-size) / 2);
        }

        .hour-marker { width: 4px; height: 20px; margin-left: -2px; }
        .minute-marker { width: 2px; height: 10px; margin-left: -1px; }

        .hand {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform-origin: bottom center;
            background: var(--primary-color);
            transform: translateX(-50%) rotate(var(--rotation-angle, 0deg));
        }

        .hour { width: 6px; height: 120px; }
        .minute { width: 4px; height: 160px; }
        .second { width: 2px; height: 180px; background: var(--accent-color); }

        .center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: var(--center-dot-size);
            height: var(--center-dot-size);
            background: var(--primary-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .number {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 40px;
            height: 40px;
            display: none;
            align-items: center;
            justify-content: center;
            margin-left: -20px;
            margin-top: -20px;
            font-size: 24px;
            font-weight: bold;
        }
        .show-numbers .number { display: flex; }
    </style>
</head>
<body class="state-digital">
    <div class="ui-controls">
        <button id="toggle" class="btn">ANALOG</button>
        <button id="format" class="btn">12H</button>
        <button id="mode" class="btn">GLIDE</button>
        <button id="numbers" class="btn">NUMBERS</button>
        <button id="timeSource" class="btn">NETWORK</button>
    </div>
    <button id="hideBtn" class="btn">HIDE</button>

    <div id="digital">00:00:00</div>

    <div id="analog">
        <div class="clock-face">
            <div id="markers"></div>
            <div id="clockNumbers"></div>
            <div class="hand hour" id="hour"></div>
            <div class="hand minute" id="minute"></div>
            <div class="hand second" id="second"></div>
            <div class="center"></div>
        </div>
    </div>

    <script>
        // -----------------
        // --- DOM Cache ---
        // -----------------
        // To improve performance, we cache all DOM elements we will interact with.
        // This avoids costly document lookups in functions that are called frequently (e.g., updateClock).
        const DOM = {
            body: document.body,
            digital: document.getElementById('digital'),
            analog: document.getElementById('analog'),
            toggle: document.getElementById('toggle'),
            format: document.getElementById('format'),
            mode: document.getElementById('mode'),
            numbers: document.getElementById('numbers'),
            timeSource: document.getElementById('timeSource'),
            hide: document.getElementById('hideBtn'),
            hands: {
                hour: document.getElementById('hour'),
                minute: document.getElementById('minute'),
                second: document.getElementById('second')
            },
            markers: document.getElementById('markers'),
            clockNumbers: document.getElementById('clockNumbers'),
            uiControls: document.querySelector('.ui-controls')
        };

        // ---------------------
        // --- State Manager ---
        // ---------------------
        // This object holds the entire state of the application.
        // All rendering and logic is driven by this state.
        const STATE = {
            isDigital: true,        // Are we showing the digital or analog clock?
            isGliding: false,       // Does the analog clock's second hand glide or tick?
            showNumbers: false,     // On the analog clock, show numbers or just markers?
            is24Hour: true,         // For the digital clock, use 24-hour or 12-hour format?
            uiHidden: false,        // Is the UI (buttons) hidden?
            useNetworkTime: true,   // Should we use network time or local system time? (Defaults to trying network time)
            networkTimeOffset: 0,   // The calculated difference in milliseconds between system time and network time.
            tickInterval: null,     // Holds the ID for the setInterval() used for the ticking clock.
            animationFrame: null,   // Holds the ID for the requestAnimationFrame() used for the gliding clock.
            periodicSyncId: null    // Holds the ID for the setInterval() used for periodic time resync.
        };

        // -----------------
        // --- Constants ---
        // -----------------
        // Configuration constants for the network time synchronization feature.
        const SYNC_CONFIG = {
            endpoint: 'https://time.now/developer/api/ip', // A public time API
            maxAttempts: 5,                                 // Max number of retries for the initial sync.
            initialDelayMs: 1000,                           // Initial delay for the exponential backoff retry strategy.
            periodicSyncMs: 5 * 60 * 1000                   // How often to resync time: 5 (minutes) * 60 (seconds) * 1000 (milliseconds).
        };

        // --------------------
        // --- Core Helpers ---
        // --------------------

        /**
         * A simple promise-based sleep function.
         * @param {number} ms - The number of milliseconds to wait.
         * @returns {Promise<void>}
         */
        const sleep = ms => new Promise(res => setTimeout(res, ms));

        // --------------------------
        // --- Time Synchronization ---
        // --------------------------

        /**
         * Fetches time from the network API with a retry mechanism.
         * This function implements an exponential backoff strategy to avoid overwhelming the server on failure.
         * It also calculates the Round-Trip Time (RTT) to compensate for network latency, giving a more accurate time.
         * @param {number} maxAttempts - The maximum number of times to try fetching the time.
         * @param {number} initialDelay - The starting delay for retries, which doubles on each failure.
         * @returns {Promise<boolean>} - True if the sync was successful, false otherwise.
         */
        async function fetchNetworkTimeWithRetries(maxAttempts = SYNC_CONFIG.maxAttempts, initialDelay = SYNC_CONFIG.initialDelayMs) {
            let attempt = 0;
            let delay = initialDelay;

            while (attempt < maxAttempts) {
                attempt++;
                try {
                    DOM.timeSource.textContent = attempt === 1 ? 'SYNCING...' : `SYNCING (${attempt})...`;
                    const t0 = Date.now(); // Timestamp before sending the request
                    const resp = await fetch(SYNC_CONFIG.endpoint, { cache: 'no-store' }); // 'no-store' is crucial for getting fresh data
                    const t1 = Date.now(); // Timestamp after receiving the response
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    const data = await resp.json();

                    // The API might return time in various formats, so we try to parse them gracefully.
                    let serverMs;
                    if (data.utc_datetime) {
                        serverMs = Date.parse(data.utc_datetime);
                    } else if (typeof data.unixtime === 'number') {
                        serverMs = data.unixtime * 1000;
                    } else {
                        serverMs = Date.parse(data.datetime || data.utc_datetime);
                    }

                    if (Number.isNaN(serverMs)) throw new Error('Invalid network time format from API');

                    // To compensate for latency, we assume the server's timestamp is from when the response
                    // was generated. We add half the round-trip time (RTT) to this value to get a
                    // more accurate estimate of the current time.
                    const rtt = t1 - t0;
                    const estimatedNetworkNowMs = serverMs + Math.round(rtt / 2);

                    const systemMs = t1; // The system time when the response was fully received.
                    STATE.networkTimeOffset = estimatedNetworkNowMs - systemMs;

                    console.log(`Sync success (attempt ${attempt}). RTT=${rtt}ms, Offset=${STATE.networkTimeOffset}ms`);
                    return true;
                } catch (err) {
                    console.warn(`Sync attempt ${attempt} failed:`, err);
                    if (attempt >= maxAttempts) break;
                    await sleep(delay);
                    delay *= 2; // Exponential backoff
                }
            }
            console.error('All network sync attempts failed.');
            return false;
        }

        /**
         * Schedules a periodic resync of the network time.
         * This ensures the clock remains accurate over long periods.
         */
        function schedulePeriodicSync() {
            clearPeriodicSync(); // Ensure no multiple intervals are running.
            STATE.periodicSyncId = setInterval(async () => {
                console.log('Periodic sync triggered.');
                // We use a smaller retry budget for periodic syncs to be less intrusive.
                const ok = await fetchNetworkTimeWithRetries(2, 500);
                if (ok) {
                    console.log('Periodic sync succeeded (offset updated).');
                } else {
                    console.warn('Periodic sync failed (kept previous offset).');
                }
            }, SYNC_CONFIG.periodicSyncMs);
        }

        /**
         * Clears any scheduled periodic sync.
         */
        function clearPeriodicSync() {
            if (STATE.periodicSyncId) {
                clearInterval(STATE.periodicSyncId);
                STATE.periodicSyncId = null;
            }
        }

        /**
         * A wrapper function to handle the full network time sync process.
         * It attempts the sync and, on success, schedules the periodic resync.
         * On failure, it ensures the clock falls back to system time.
         * @returns {Promise<boolean>} - The result from fetchNetworkTimeWithRetries.
         */
        async function fetchNetworkTime() {
            const success = await fetchNetworkTimeWithRetries();
            if (success) {
                STATE.useNetworkTime = true;
                updateClock();
                schedulePeriodicSync();
            } else {
                STATE.useNetworkTime = false;
                clearPeriodicSync();
            }
            renderUI();
            saveState(); // Persist the outcome of the sync attempt.
            return success;
        }


        // -------------------
        // --- Clock Logic ---
        // -------------------

        /**
         * Gets the current time, applying the network offset if available.
         * @returns {Date} The current, potentially network-adjusted, time.
         */
        function getCurrentTime() {
            const systemTime = new Date();
            if (STATE.useNetworkTime && STATE.networkTimeOffset !== 0) {
                return new Date(systemTime.getTime() + STATE.networkTimeOffset);
            }
            return systemTime;
        }

        /**
         * The main clock update function. It gets the current time and calls the
         * specific update functions for both digital and analog displays.
         */
        function updateClock() {
            const now = getCurrentTime();
            const time = {
                hours: now.getHours(),
                minutes: now.getMinutes(),
                seconds: now.getSeconds(),
                milliseconds: STATE.isGliding ? now.getMilliseconds() : 0 // Only need ms for glide mode
            };
            updateDigitalClock(time);
            updateAnalogClock(time);
        }

        /**
         * Updates the text content of the digital clock display.
         * @param {{hours: number, minutes: number, seconds: number}} time - The time to display.
         */
        function updateDigitalClock({ hours, minutes, seconds }) {
            const pad = n => n.toString().padStart(2, '0');
            let displayHours = hours;
            let suffix = '';

            if (!STATE.is24Hour) {
                suffix = hours >= 12 ? ' PM' : ' AM';
                displayHours = hours % 12 || 12; // 0 or 12 should be 12
            }

            DOM.digital.textContent = `${pad(displayHours)}:${pad(minutes)}:${pad(seconds)}${suffix}`;
        }

        /**
         * Updates the rotation of the analog clock hands.
         * Calculations include fractional values for smooth "gliding" movement.
         * @param {{hours: number, minutes: number, seconds: number, milliseconds: number}} time - The time to display.
         */
        function updateAnalogClock({ hours, minutes, seconds, milliseconds }) {
            // By including milliseconds/seconds in the larger units, the hands move smoothly.
            const secondsWithMs = seconds + milliseconds / 1000;
            const minutesWithSeconds = minutes + secondsWithMs / 60;
            const hoursWithMinutes = (hours % 12) + minutesWithSeconds / 60;

            const angles = {
                second: secondsWithMs * 6,      // 360 / 60 = 6
                minute: minutesWithSeconds * 6, // 360 / 60 = 6
                hour: hoursWithMinutes * 30     // 360 / 12 = 30
            };

            // Using CSS custom properties for rotation is a clean way to update the styles.
            DOM.hands.second.style.setProperty('--rotation-angle', `${angles.second}deg`);
            DOM.hands.minute.style.setProperty('--rotation-angle', `${angles.minute}deg`);
            DOM.hands.hour.style.setProperty('--rotation-angle', `${angles.hour}deg`);
        }

        /**
         * The animation loop for the "gliding" clock mode.
         * It calls itself recursively using requestAnimationFrame for smooth, efficient animation.
         */
        function animate() {
            updateClock();
            if (STATE.isGliding) {
                STATE.animationFrame = requestAnimationFrame(animate);
            }
        }


        // --------------------------
        // --- UI & State Toggles ---
        // --------------------------

        /**
         * Renders the entire UI based on the current STATE object.
         * This function is the single source of truth for how the UI looks.
         * It toggles CSS classes and updates button text.
         */
        function renderUI() {
            DOM.body.classList.toggle('state-digital', STATE.isDigital);
            DOM.body.classList.toggle('state-analog', !STATE.isDigital);
            DOM.body.classList.toggle('ui-hidden', STATE.uiHidden);
            DOM.clockNumbers.classList.toggle('show-numbers', STATE.showNumbers);

            // Update button text based on state
            DOM.hide.textContent = STATE.uiHidden ? '*' : 'HIDE';
            DOM.toggle.textContent = STATE.isDigital ? 'ANALOG' : 'DIGITAL';
            DOM.format.textContent = STATE.is24Hour ? '12H' : '24H';
            DOM.mode.textContent = STATE.isGliding ? 'TICK' : 'GLIDE';
            DOM.numbers.textContent = STATE.showNumbers ? 'MARKERS' : 'NUMBERS';
            DOM.timeSource.textContent = STATE.useNetworkTime ? 'NETWORK' : 'SYSTEM';
        }

        /**
         * Saves the current application state to localStorage.
         * Volatile properties like interval IDs are excluded as they are not meaningful across sessions.
         * This function is called after every state change to ensure persistence.
         * Note: For extremely frequent updates, one might debounce this function,
         * but for user-driven clicks, direct saving is simple and reliable.
         */
        function saveState() {
            const stateToSave = { ...STATE };
            // We don't want to save interval/animation IDs.
            delete stateToSave.tickInterval;
            delete stateToSave.animationFrame;
            delete stateToSave.periodicSyncId;
            localStorage.setItem('chronoState', JSON.stringify(stateToSave));
        }

        /**
         * Loads application state from localStorage.
         * If state is found, it's parsed and merged into the current STATE object.
         * This is called once on initialization.
         */
        function loadState() {
            const savedState = localStorage.getItem('chronoState');
            if (savedState) {
                try {
                    const parsedState = JSON.parse(savedState);
                    // Merge the loaded state, but ensure volatile properties are reset.
                    Object.assign(STATE, {
                        ...parsedState,
                        tickInterval: null,
                        animationFrame: null,
                        periodicSyncId: null,
                    });
                } catch (e) {
                    console.error("Failed to parse saved state from localStorage:", e);
                }
            }
        }

        // --- Event Handlers for UI buttons ---

        function toggleClockMode() {
            STATE.isDigital = !STATE.isDigital;
            renderUI();
            saveState();
        }

        function toggleTimeFormat() {
            STATE.is24Hour = !STATE.is24Hour;
            updateClock();
            renderUI();
            saveState();
        }

        /**
         * Toggles between "ticking" (setInterval) and "gliding" (requestAnimationFrame) clock modes.
         */
        function toggleGlideMode() {
            STATE.isGliding = !STATE.isGliding;
            if (STATE.isGliding) {
                // Switch to animation frame loop
                clearInterval(STATE.tickInterval);
                STATE.tickInterval = null;
                animate();
            } else {
                // Switch back to interval-based ticking
                cancelAnimationFrame(STATE.animationFrame);
                STATE.animationFrame = null;
                updateClock(); // Ensure final position is correct
                if (!STATE.tickInterval) {
                    STATE.tickInterval = setInterval(updateClock, 1000);
                }
            }
            renderUI();
            saveState();
        }

        function toggleNumbers() {
            STATE.showNumbers = !STATE.showNumbers;
            renderUI();
            saveState();
        }

        function toggleUIVisibility() {
            STATE.uiHidden = !STATE.uiHidden;
            renderUI();
            saveState();
        }

        /**
         * Toggles between using network time and local system time.
         */
        async function toggleTimeSource() {
            const wantNetwork = !STATE.useNetworkTime;
            if (wantNetwork) {
                // When switching to network time, we must perform a sync.
                DOM.timeSource.textContent = 'SYNCING...';
                const ok = await fetchNetworkTime();
                if (!ok) {
                    // If sync fails, show a "FAILED" message briefly before UI reverts.
                    DOM.timeSource.textContent = 'FAILED';
                    setTimeout(() => renderUI(), 1500);
                }
            } else {
                // When switching to system time, we just stop syncing and use local time.
                STATE.useNetworkTime = false;
                clearPeriodicSync();
                updateClock();
                saveState();
                renderUI();
            }
        }


        // --------------------------
        // --- Initialization ---
        // --------------------------

        /**
         * Attaches all the necessary event listeners to the UI controls.
         */
        function attachEventListeners() {
            DOM.toggle.addEventListener('click', toggleClockMode);
            DOM.format.addEventListener('click', toggleTimeFormat);
            DOM.mode.addEventListener('click', toggleGlideMode);
            DOM.numbers.addEventListener('click', toggleNumbers);
            DOM.hide.addEventListener('click', toggleUIVisibility);
            DOM.timeSource.addEventListener('click', toggleTimeSource);
        }

        /**
         * Generates the 60 minute/hour markers for the analog clock face.
         * Using a DocumentFragment is more performant because it minimizes DOM reflows.
         */
        function generateMarkers() {
            const fragment = document.createDocumentFragment();
            for (let i = 0; i < 60; i++) {
                const marker = document.createElement('div');
                const isHourMarker = i % 5 === 0;
                marker.className = `marker ${isHourMarker ? 'hour-marker' : 'minute-marker'}`;
                marker.style.transform = `rotate(${i * 6}deg)`;
                fragment.appendChild(marker);
            }
            DOM.markers.appendChild(fragment);
        }

        /**
         * Generates the 12 numbers for the analog clock face.
         */
        function generateNumbers() {
            const RADIUS = 150; // The radius for positioning the numbers.
            const fragment = document.createDocumentFragment();
            for (let i = 1; i <= 12; i++) {
                const num = document.createElement('div');
                num.className = 'number';
                // Calculate the x and y position of each number using trigonometry.
                // We subtract 90 degrees (PI/2) to start '12' at the top.
                const angle = (i * 30 - 90) * (Math.PI / 180);
                const x = Math.cos(angle) * RADIUS;
                const y = Math.sin(angle) * RADIUS;
                num.style.transform = `translate(${x}px, ${y}px)`;
                num.textContent = i;
                fragment.appendChild(num);
            }
            DOM.clockNumbers.appendChild(fragment);
        }

        /**
         * The main initialization function for the application.
         */
        async function init() {
            // 1. Load any saved state from the previous session.
            loadState();

            // 2. Generate the static parts of the analog clock face.
            generateMarkers();
            generateNumbers();

            // 3. Attach event listeners to all buttons.
            attachEventListeners();

            // 4. Render the UI in its initial state.
            renderUI();
            
            // 5. Do an initial clock update to avoid seeing 00:00:00.
            updateClock();

            // 6. Start the appropriate clock update loop.
            if (STATE.isGliding) {
                animate();
            } else {
                if (!STATE.tickInterval) {
                    STATE.tickInterval = setInterval(updateClock, 1000);
                }
            }

            // 7. If using network time, attempt an initial sync.
            // This happens after the first render so the user sees a clock immediately.
            if (STATE.useNetworkTime) {
                DOM.timeSource.textContent = 'SYNCING...'; // Show feedback that sync is in progress.
                const ok = await fetchNetworkTime();
                if (!ok) {
                    // If sync fails, revert to system time and show a brief failure message.
                    STATE.useNetworkTime = false;
                    DOM.timeSource.textContent = 'FAILED';
                    setTimeout(() => renderUI(), 1500);
                }
            }
        }

        // --- App Start ---
        init();
    </script>
</body>
</html>
